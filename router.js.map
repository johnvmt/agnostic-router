{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/url-pattern/lib/url-pattern.js","src/Router.js"],"names":["slice","root","factory","define","amd","exports","module","UrlPattern","this","P","astNodeContainsSegmentsForProvidedParams","astNodeToNames","astNodeToRegexString","baseAstNodeToRegexString","concatMap","defaultOptions","escapeForRegex","getParam","keysAndValuesToObject","newParser","regexGroupCount","stringConcatMap","stringify","string","replace","array","f","i","length","results","concat","result","regex","RegExp","toString","exec","keys","values","key","object","value","Array","isArray","push","Result","rest","Tagged","tag","parser","input","tagged","matches","sequence","parsers","arguments","call","pick","indexes","apply","lazy","fn","cached","baseMany","end","stringResult","atLeastOneResultRequired","endResult","parserResult","many1","concatMany1Till","firstChoice","options","U","wildcard","wildcardChar","optional","optionalSegmentStartChar","pattern","optionalSegmentEndChar","name","segmentNameCharset","named","segmentNameStartChar","escapedChar","escapeChar","token","segmentValueCharset","astNode","node","params","nextIndexes","sideEffects","index","maxIndex","Error","arg1","arg2","groupCount","parsed","withoutWhitespace","isRegex","ast","names","TypeError","prototype","match","url","groups","Object","Router","useRoutes","methodRoutes","require","route","queueNext","routeMatch","routeMatches","shift","request","handler","respond","_isRouter","method","queueEnd","path","_methodPathMatches","use","_validHandler","_addRouteToArray","_normalizePath","useFirst","pathNormalized","self","forEach","prepend","unshift"],"mappings":"AAAA;ACCA,GAAIA,UAAWA,OAEf,SAAUC,EAAMC,GACd,MAAK,kBAAsBC,SAA0B,MAAdA,OAAOC,IACrCD,UAAWD,GACU,mBAAZG,UAAuC,OAAZA,QACpCC,OAAOD,QAAUH,IAEjBD,EAAKM,WAAaL,KAE1BM,KAAM,WACP,GAAIC,GAAGF,EAAYG,EAA0CC,EAAgBC,EAAsBC,EAA0BC,EAAWC,EAAgBC,EAAgBC,EAAUC,EAAuBC,EAAWC,EAAiBC,EAAiBC,CAsatP,OAraAN,GAAiB,SAASO,GACxB,MAAOA,GAAOC,QAAQ,yBAA0B,SAElDV,EAAY,SAASW,EAAOC,GAC1B,GAAIC,GAAGC,EAAQC,CAIf,KAHAA,KACAF,GAAI,EACJC,EAASH,EAAMG,SACND,EAAIC,GACXC,EAAUA,EAAQC,OAAOJ,EAAED,EAAME,IAEnC,OAAOE,IAETR,EAAkB,SAASI,EAAOC,GAChC,GAAIC,GAAGC,EAAQG,CAIf,KAHAA,EAAS,GACTJ,GAAI,EACJC,EAASH,EAAMG,SACND,EAAIC,GACXG,GAAUL,EAAED,EAAME,GAEpB,OAAOI,IAETX,EAAkB,SAASY,GACzB,MAAO,IAAKC,QAAOD,EAAME,WAAa,KAAMC,KAAK,IAAIP,OAAS,GAEhEV,EAAwB,SAASkB,EAAMC,GACrC,GAAIV,GAAGW,EAAKV,EAAQW,EAAQC,CAI5B,KAHAD,KACAZ,GAAI,EACJC,EAASQ,EAAKR,SACLD,EAAIC,GACXU,EAAMF,EAAKT,GACXa,EAAQH,EAAOV,GACF,MAATa,IAGe,MAAfD,EAAOD,IACJG,MAAMC,QAAQH,EAAOD,MACxBC,EAAOD,IAAQC,EAAOD,KAExBC,EAAOD,GAAKK,KAAKH,IAEjBD,EAAOD,GAAOE,EAGlB,OAAOD,IAET9B,KACAA,EAAEmC,OAAS,SAASJ,EAAOK,GACzBrC,KAAKgC,MAAQA,EACbhC,KAAKqC,KAAOA,GAEdpC,EAAEqC,OAAS,SAASC,EAAKP,GACvBhC,KAAKuC,IAAMA,EACXvC,KAAKgC,MAAQA,GAEf/B,EAAEsC,IAAM,SAASA,EAAKC,GACpB,MAAO,UAASC,GACd,GAAIlB,GAAQmB,CAEZ,IADAnB,EAASiB,EAAOC,GACF,MAAVlB,EAIJ,MADAmB,GAAS,GAAIzC,GAAEqC,OAAOC,EAAKhB,EAAOS,OAC3B,GAAI/B,GAAEmC,OAAOM,EAAQnB,EAAOc,QAGvCpC,EAAEuB,MAAQ,SAASA,GACjB,MAAO,UAASiB,GACd,GAAIE,GAASpB,CAEb,IADAoB,EAAUnB,EAAMG,KAAKc,GACN,MAAXE,EAIJ,MADApB,GAASoB,EAAQ,GACV,GAAI1C,GAAEmC,OAAOb,EAAQkB,EAAMjD,MAAM+B,EAAOH,WAGnDnB,EAAE2C,SAAW,WACX,GAAIC,EAEJ,OADAA,GAAU,GAAKC,UAAU1B,OAAS5B,MAAMuD,KAAKD,UAAW,MACjD,SAASL,GACd,GAAItB,GAAGC,EAAQoB,EAAQH,EAAMd,EAAQM,CAKrC,KAJAV,GAAI,EACJC,EAASyB,EAAQzB,OACjBS,KACAQ,EAAOI,IACEtB,EAAIC,GAAQ,CAGnB,GAFAoB,EAASK,EAAQ1B,GACjBI,EAASiB,EAAOH,GACF,MAAVd,EACF,MAEFM,GAAOM,KAAKZ,EAAOS,OACnBK,EAAOd,EAAOc,KAEhB,MAAO,IAAIpC,GAAEmC,OAAOP,EAAQQ,KAGhCpC,EAAE+C,KAAO,WACP,GAAIC,GAASJ,CAEb,OADAI,GAAUH,UAAU,GAAID,EAAU,GAAKC,UAAU1B,OAAS5B,MAAMuD,KAAKD,UAAW,MACzE,SAASL,GACd,GAAIxB,GAAOM,CAEX,IADAA,EAAStB,EAAE2C,SAASM,MAAMjD,EAAG4C,GAASJ,GACxB,MAAVlB,EAKJ,MAFAN,GAAQM,EAAOS,MACfT,EAAOS,MAAQf,EAAMgC,GACd1B,IAGXtB,EAAEc,OAAS,SAASA,GAClB,GAAIK,EAEJ,OADAA,GAASL,EAAOK,OACT,SAASqB,GACd,GAAIA,EAAMjD,MAAM,EAAG4B,KAAYL,EAC7B,MAAO,IAAId,GAAEmC,OAAOrB,EAAQ0B,EAAMjD,MAAM4B,MAI9CnB,EAAEkD,KAAO,SAASC,GAChB,GAAIC,EAEJ,OADAA,GAAS,KACF,SAASZ,GAId,MAHc,OAAVY,IACFA,EAASD,KAEJC,EAAOZ,KAGlBxC,EAAEqD,SAAW,SAASd,EAAQe,EAAKC,EAAcC,EAA0BhB,GACzE,GAAIiB,GAAWC,EAActB,EAAMhB,CAGnC,KAFAgB,EAAOI,EACPpB,EAAUmC,EAAe,QACZ,CACX,GAAW,MAAPD,IACFG,EAAYH,EAAIlB,GACC,MAAbqB,GACF,KAIJ,IADAC,EAAenB,EAAOH,GACF,MAAhBsB,EACF,KAEEH,GACFnC,GAAWsC,EAAa3B,MAExBX,EAAQc,KAAKwB,EAAa3B,OAE5BK,EAAOsB,EAAatB,KAEtB,IAAIoB,GAA+C,IAAnBpC,EAAQD,OAGxC,MAAO,IAAInB,GAAEmC,OAAOf,EAASgB,IAE/BpC,EAAE2D,MAAQ,SAASpB,GACjB,MAAO,UAASC,GACd,MAAOxC,GAAEqD,SAASd,EAAQ,MAAM,GAAO,EAAMC,KAGjDxC,EAAE4D,gBAAkB,SAASrB,EAAQe,GACnC,MAAO,UAASd,GACd,MAAOxC,GAAEqD,SAASd,EAAQe,GAAK,GAAM,EAAMd,KAG/CxC,EAAE6D,YAAc,WACd,GAAIjB,EAEJ,OADAA,GAAU,GAAKC,UAAU1B,OAAS5B,MAAMuD,KAAKD,UAAW,MACjD,SAASL,GACd,GAAItB,GAAGC,EAAQoB,EAAQjB,CAGvB,KAFAJ,GAAI,EACJC,EAASyB,EAAQzB,SACRD,EAAIC,GAGX,GAFAoB,EAASK,EAAQ1B,GACjBI,EAASiB,EAAOC,GACF,MAAVlB,EACF,MAAOA,KAKfZ,EAAY,SAASoD,GACnB,GAAIC,EAoBJ,OAnBAA,MACAA,EAAEC,SAAWhE,EAAEsC,IAAI,WAAYtC,EAAEc,OAAOgD,EAAQG,eAChDF,EAAEG,SAAWlE,EAAEsC,IAAI,WAAYtC,EAAE+C,KAAK,EAAG/C,EAAEc,OAAOgD,EAAQK,0BAA2BnE,EAAEkD,KAAK,WAC1F,MAAOa,GAAEK,UACPpE,EAAEc,OAAOgD,EAAQO,0BACrBN,EAAEO,KAAOtE,EAAEuB,MAAM,GAAIC,QAAO,KAAOsC,EAAQS,mBAAqB,OAChER,EAAES,MAAQxE,EAAEsC,IAAI,QAAStC,EAAE+C,KAAK,EAAG/C,EAAEc,OAAOgD,EAAQW,sBAAuBzE,EAAEkD,KAAK,WAChF,MAAOa,GAAEO,SAEXP,EAAEW,YAAc1E,EAAE+C,KAAK,EAAG/C,EAAEc,OAAOgD,EAAQa,YAAa3E,EAAEuB,MAAM,OAChEwC,EAAU,OAAI/D,EAAEsC,IAAI,SAAUtC,EAAE4D,gBAAgB5D,EAAE6D,YAAY7D,EAAEkD,KAAK,WACnE,MAAOa,GAAEW,cACP1E,EAAEuB,MAAM,OAAQvB,EAAE6D,YAAY7D,EAAEc,OAAOgD,EAAQW,sBAAuBzE,EAAEc,OAAOgD,EAAQK,0BAA2BnE,EAAEc,OAAOgD,EAAQO,wBAAyBN,EAAEC,YAClKD,EAAEa,MAAQ5E,EAAEkD,KAAK,WACf,MAAOlD,GAAE6D,YAAYE,EAAEC,SAAUD,EAAEG,SAAUH,EAAES,MAAOT,EAAU,UAElEA,EAAEK,QAAUpE,EAAE2D,MAAM3D,EAAEkD,KAAK,WACzB,MAAOa,GAAEa,SAEJb,GAETzD,GACEqE,WAAY,KACZF,qBAAsB,IACtBI,oBAAqB,iBACrBN,mBAAoB,YACpBJ,yBAA0B,IAC1BE,uBAAwB,IACxBJ,aAAc,KAEhB7D,EAA2B,SAAS0E,EAASD,GAC3C,GAAI7C,MAAMC,QAAQ6C,GAChB,MAAOlE,GAAgBkE,EAAS,SAASC,GACvC,MAAO3E,GAAyB2E,EAAMF,IAG1C,QAAQC,EAAQxC,KACd,IAAK,WACH,MAAO,OACT,KAAK,QACH,MAAO,KAAOuC,EAAsB,KACtC,KAAK,SACH,MAAOtE,GAAeuE,EAAQ/C,MAChC,KAAK,WACH,MAAO,MAAQ3B,EAAyB0E,EAAQ/C,MAAO8C,GAAuB,OAGpF1E,EAAuB,SAAS2E,EAASD,GAIvC,MAH2B,OAAvBA,IACFA,EAAsBvE,EAAeuE,qBAEhC,IAAMzE,EAAyB0E,EAASD,GAAuB,KAExE3E,EAAiB,SAAS4E,GACxB,GAAI9C,MAAMC,QAAQ6C,GAChB,MAAOzE,GAAUyE,EAAS5E,EAE5B,QAAQ4E,EAAQxC,KACd,IAAK,WACH,OAAQ,IACV,KAAK,QACH,OAAQwC,EAAQ/C,MAClB,KAAK,SACH,QACF,KAAK,WACH,MAAO7B,GAAe4E,EAAQ/C,SAGpCvB,EAAW,SAASwE,EAAQnD,EAAKoD,EAAaC,GAC5C,GAAIC,GAAOC,EAAU9D,EAAQS,CAK7B,IAJmB,MAAfmD,IACFA,GAAc,GAEhBnD,EAAQiD,EAAOnD,GACF,MAATE,EAAJ,CASA,GAFAoD,EAAQF,EAAYpD,IAAQ,EAC5BuD,EAAWpD,MAAMC,QAAQF,GAASA,EAAMZ,OAAS,EAAI,IACjDgE,EAAQC,GAWZ,MAJA9D,GAASU,MAAMC,QAAQF,GAASA,EAAMoD,GAASpD,EAC3CmD,IACFD,EAAYpD,GAAOsD,EAAQ,GAEtB7D,CAVL,IAAI4D,EACF,KAAM,IAAIG,OAAM,oCAAsCxD,EAAM,SAV9D,IAAIqD,EACF,KAAM,IAAIG,OAAM,+BAAiCxD,EAAM,MAoB7D5B,EAA2C,SAAS6E,EAASE,EAAQC,GACnE,GAAI/D,GAAGC,CACP,IAAIa,MAAMC,QAAQ6C,GAAU,CAG1B,IAFA5D,GAAI,EACJC,EAAS2D,EAAQ3D,SACRD,EAAIC,GACX,GAAIlB,EAAyC6E,EAAQ5D,GAAI8D,EAAQC,GAC/D,OAAO,CAGX,QAAO,EAET,OAAQH,EAAQxC,KACd,IAAK,WACH,MAAoD,OAA7C9B,EAASwE,EAAQ,IAAKC,GAAa,EAC5C,KAAK,QACH,MAA8D,OAAvDzE,EAASwE,EAAQF,EAAQ/C,MAAOkD,GAAa,EACtD,KAAK,SACH,OAAO,CACT,KAAK,WACH,MAAOhF,GAAyC6E,EAAQ/C,MAAOiD,EAAQC,KAG7EpE,EAAY,SAASiE,EAASE,EAAQC,GACpC,GAAIjD,MAAMC,QAAQ6C,GAChB,MAAOlE,GAAgBkE,EAAS,SAASC,GACvC,MAAOlE,GAAUkE,EAAMC,EAAQC,IAGnC,QAAQH,EAAQxC,KACd,IAAK,WACH,MAAO9B,GAASwE,EAAQ,IAAKC,GAAa,EAC5C,KAAK,QACH,MAAOzE,GAASwE,EAAQF,EAAQ/C,MAAOkD,GAAa,EACtD,KAAK,SACH,MAAOH,GAAQ/C,KACjB,KAAK,WACH,MAAI9B,GAAyC6E,EAAQ/C,MAAOiD,EAAQC,GAC3DpE,EAAUiE,EAAQ/C,MAAOiD,EAAQC,GAEjC,KAIfnF,EAAa,SAASwF,EAAMC,GAC1B,GAAIC,GAAY1B,EAAS2B,EAAQlD,EAAQmD,CACzC,IAAIJ,YAAgBxF,GAKlB,MAJAC,MAAK4F,QAAUL,EAAKK,QACpB5F,KAAKwB,MAAQ+D,EAAK/D,MAClBxB,KAAK6F,IAAMN,EAAKM,SAChB7F,KAAK8F,MAAQP,EAAKO,MAIpB,IADA9F,KAAK4F,QAAUL,YAAgB9D,QACxB,gBAAoB8D,KAASvF,KAAK4F,QACvC,KAAM,IAAIG,WAAU,uCAEtB,IAAI/F,KAAK4F,SAEP,GADA5F,KAAKwB,MAAQ+D,EACD,MAARC,EAAc,CAChB,IAAKvD,MAAMC,QAAQsD,GACjB,KAAM,IAAIF,OAAM,kHAGlB,IADAG,EAAa7E,EAAgBZ,KAAKwB,OAC9BgE,EAAKpE,SAAWqE,EAClB,KAAM,IAAIH,OAAM,kBAAoBG,EAAa,6CAA+CD,EAAKpE,OAEvGpB,MAAK8F,MAAQN,OAVjB,CAcA,GAAa,KAATD,EACF,KAAM,IAAID,OAAM,wCAGlB,IADAK,EAAoBJ,EAAKvE,QAAQ,OAAQ,IACrC2E,IAAsBJ,EACxB,KAAM,IAAID,OAAM,uCAalB,IAXAvB,GACEa,YAAqB,MAARY,EAAeA,EAAKZ,WAAa,SAAWrE,EAAeqE,WACxEF,sBAA+B,MAARc,EAAeA,EAAKd,qBAAuB,SAAWnE,EAAemE,qBAC5FF,oBAA6B,MAARgB,EAAeA,EAAKhB,mBAAqB,SAAWjE,EAAeiE,mBACxFM,qBAA8B,MAARU,EAAeA,EAAKV,oBAAsB,SAAWvE,EAAeuE,oBAC1FV,0BAAmC,MAARoB,EAAeA,EAAKpB,yBAA2B,SAAW7D,EAAe6D,yBACpGE,wBAAiC,MAARkB,EAAeA,EAAKlB,uBAAyB,SAAW/D,EAAe+D,uBAChGJ,cAAuB,MAARsB,EAAeA,EAAKtB,aAAe,SAAW3D,EAAe2D,cAE9E1B,EAAS7B,EAAUoD,GACnB2B,EAASlD,EAAO6B,QAAQkB,GACV,MAAVG,EACF,KAAM,IAAIJ,OAAM,yBAElB,IAAoB,KAAhBI,EAAOrD,KACT,KAAM,IAAIiD,OAAM,qCAElBtF,MAAK6F,IAAMH,EAAO1D,MAClBhC,KAAKwB,MAAQ,GAAIC,QAAOrB,EAAqBJ,KAAK6F,IAAK9B,EAAQe,sBAC/D9E,KAAK8F,MAAQ3F,EAAeH,KAAK6F,OAEnC9F,EAAWiG,UAAUC,MAAQ,SAASC,GACpC,GAAIC,GAAQF,CAEZ,OADAA,GAAQjG,KAAKwB,MAAMG,KAAKuE,GACX,MAATD,EACK,MAETE,EAASF,EAAMzG,MAAM,GACjBQ,KAAK8F,MACApF,EAAsBV,KAAK8F,MAAOK,GAElCA,IAGXpG,EAAWiG,UAAUlF,UAAY,SAASmE,GAIxC,GAHc,MAAVA,IACFA,MAEEjF,KAAK4F,QACP,KAAM,IAAIN,OAAM,kDAElB,IAAIL,IAAWmB,OAAOnB,GACpB,KAAM,IAAIK,OAAM,0CAElB,OAAOxE,GAAUd,KAAK6F,IAAKZ,OAE7BlF,EAAWS,eAAiBA,EAC5BT,EAAWO,UAAYA,EACvBP,EAAWc,gBAAkBA,EAC7Bd,EAAWa,gBAAkBA,EAC7Bb,EAAWW,sBAAwBA,EACnCX,EAAWE,EAAIA,EACfF,EAAWY,UAAYA,EACvBZ,EAAWQ,eAAiBA,EAC5BR,EAAWK,qBAAuBA,EAClCL,EAAWI,eAAiBA,EAC5BJ,EAAWU,SAAWA,EACtBV,EAAWG,yCAA2CA,EACtDH,EAAWe,UAAYA,EAChBf;;AChbT,QAASsG,UACRrG,KAAKsG,aACLtG,KAAKuG,gBACLvG,KAAKoF,MAAQ,EALd,GAAIrF,YAAayG,QAAQ,cAQzBH,QAAOL,UAAUS,MAAQ,WAuBxB,QAASC,KACR,GAAIC,GAAaC,EAAaC,OACL,oBAAfF,IACTG,EAAQ7B,OAAS0B,EAAW1B,OACK,kBAAvB0B,GAAWI,QACpBJ,EAAWI,QAAQD,EAASE,EAASN,GAC9BL,OAAOY,UAAUN,EAAWI,SACnCJ,EAAWI,QAAQN,MAAMK,EAAQI,OAAQ,IAAMJ,EAAQ7B,OAAU,EAAG6B,EAASE,EAASN,GAEtFA,KAE0B,kBAAbS,IACdA,IAjCF,GAAuB,GAApBrE,UAAU1B,OACZ,GAAI0F,MACAE,EAAUlE,UAAU,OAEpB,IAAGA,UAAU1B,QAAU,EAAG,CAC9B,GAAI0F,GAAUhE,UAAU,EACF,iBAAZgE,IAAyBA,IAClCA,KACD,IAAIE,GAAUlE,UAAU,GAEzBgE,EAAQI,OAASpE,UAAU,EAE3B,IAAIsE,GAAOtE,UAAU,EACM,oBAAjBgE,GAAQM,OACjBN,EAAQM,KAAOA,EAEhB,IAAID,GAAWrE,UAAU,GAErB8D,EAAe5G,KAAKqH,mBAAmBP,EAAQI,OAAQE,EAC3DV,MAmBDL,OAAOL,UAAUsB,IAAM,WAEtB,GAAIF,GAAgC,gBAAjBtE,WAAU,GAAmBA,UAAU,GAAK,GAC3DiE,EAAUV,OAAOkB,cAAczE,UAAU,IAAMA,UAAU,GAAKA,UAAU,EAE5E,OAAO9C,MAAKwH,iBAAiBxH,KAAKsG,UAAWD,OAAOoB,eAAeL,GAAOL,IAG3EV,OAAOL,UAAU0B,SAAW,WAE3B,GAAIN,GAAgC,gBAAjBtE,WAAU,GAAmBA,UAAU,GAAK,GAC3DiE,EAAUV,OAAOkB,cAAczE,UAAU,IAAMA,UAAU,GAAKA,UAAU,EAE5E,OAAO9C,MAAKwH,iBAAiBxH,KAAKsG,UAAWD,OAAOoB,eAAeL,GAAOL,GAAS,IAGpFV,OAAOL,UAAUkB,OAAS,SAASA,EAAQE,EAAML,GAGhD,MAFK/G,MAAKuG,aAAaW,YAAmBjF,SACzCjC,KAAKuG,aAAaW,OACZlH,KAAKwH,iBAAiBxH,KAAKuG,aAAaW,GAASb,OAAOoB,eAAeL,GAAOL,IAItFV,OAAOkB,cAAgB,SAASR,GAC/B,MAA2B,kBAAZA,IAA0BV,OAAOY,UAAUF,IAG3DV,OAAOY,UAAY,SAASF,GAC3B,MAA2B,gBAAZA,IAAiD,kBAAlBA,GAAQN,OAGvDJ,OAAOoB,eAAiB,SAASL,GAChC,MAAOA,GAAKpG,QAAQ,MAAO,KAG5BqF,OAAOL,UAAUqB,mBAAqB,SAASH,EAAQE,GACtD,GAAIO,GAAiBtB,OAAOoB,eAAeL,GACvCzE,KACAiF,EAAO5H,IAkBX,OAhBA4H,GAAKtB,UAAUuB,QAAQ,SAASpB,GAC/B,GAAIE,GAAa,GAAK5G,YAAW0G,EAAMW,KAAO,QAASnB,MAAM0B,EAE3C,QAAfhB,GACFhE,EAAQR,MAAMiF,KAAMX,EAAMW,KAAML,QAASN,EAAMM,QAAS9B,OAAQ0B,MAG/DiB,EAAKrB,aAAaW,YAAmBjF,QACvC2F,EAAKrB,aAAaW,GAAQW,QAAQ,SAASpB,GAC1C,GAAIE,GAAa,GAAK5G,YAAW0G,EAAMW,MAAOnB,MAAM0B,EAElC,QAAfhB,GACFhE,EAAQR,MAAMiF,KAAMX,EAAMW,KAAML,QAASN,EAAMM,QAAS9B,OAAQ0B,MAI5DhE,GAGR0D,OAAOL,UAAUwB,iBAAmB,SAASvG,EAAOmG,EAAML,EAASe,GAClE,GAAIrB,IAASW,KAAMA,EAAML,QAASA,EACZ,kBAAZe,GACT7G,EAAM8G,QAAQtB,GAEdxF,EAAMkB,KAAKsE,IAGb3G,OAAOD,QAAU,WAChB,MAAO,IAAIwG","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// Generated by CoffeeScript 1.10.0\nvar slice = [].slice;\n\n(function(root, factory) {\n  if (('function' === typeof define) && (define.amd != null)) {\n    return define([], factory);\n  } else if (typeof exports !== \"undefined\" && exports !== null) {\n    return module.exports = factory();\n  } else {\n    return root.UrlPattern = factory();\n  }\n})(this, function() {\n  var P, UrlPattern, astNodeContainsSegmentsForProvidedParams, astNodeToNames, astNodeToRegexString, baseAstNodeToRegexString, concatMap, defaultOptions, escapeForRegex, getParam, keysAndValuesToObject, newParser, regexGroupCount, stringConcatMap, stringify;\n  escapeForRegex = function(string) {\n    return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  };\n  concatMap = function(array, f) {\n    var i, length, results;\n    results = [];\n    i = -1;\n    length = array.length;\n    while (++i < length) {\n      results = results.concat(f(array[i]));\n    }\n    return results;\n  };\n  stringConcatMap = function(array, f) {\n    var i, length, result;\n    result = '';\n    i = -1;\n    length = array.length;\n    while (++i < length) {\n      result += f(array[i]);\n    }\n    return result;\n  };\n  regexGroupCount = function(regex) {\n    return (new RegExp(regex.toString() + '|')).exec('').length - 1;\n  };\n  keysAndValuesToObject = function(keys, values) {\n    var i, key, length, object, value;\n    object = {};\n    i = -1;\n    length = keys.length;\n    while (++i < length) {\n      key = keys[i];\n      value = values[i];\n      if (value == null) {\n        continue;\n      }\n      if (object[key] != null) {\n        if (!Array.isArray(object[key])) {\n          object[key] = [object[key]];\n        }\n        object[key].push(value);\n      } else {\n        object[key] = value;\n      }\n    }\n    return object;\n  };\n  P = {};\n  P.Result = function(value, rest) {\n    this.value = value;\n    this.rest = rest;\n  };\n  P.Tagged = function(tag, value) {\n    this.tag = tag;\n    this.value = value;\n  };\n  P.tag = function(tag, parser) {\n    return function(input) {\n      var result, tagged;\n      result = parser(input);\n      if (result == null) {\n        return;\n      }\n      tagged = new P.Tagged(tag, result.value);\n      return new P.Result(tagged, result.rest);\n    };\n  };\n  P.regex = function(regex) {\n    return function(input) {\n      var matches, result;\n      matches = regex.exec(input);\n      if (matches == null) {\n        return;\n      }\n      result = matches[0];\n      return new P.Result(result, input.slice(result.length));\n    };\n  };\n  P.sequence = function() {\n    var parsers;\n    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function(input) {\n      var i, length, parser, rest, result, values;\n      i = -1;\n      length = parsers.length;\n      values = [];\n      rest = input;\n      while (++i < length) {\n        parser = parsers[i];\n        result = parser(rest);\n        if (result == null) {\n          return;\n        }\n        values.push(result.value);\n        rest = result.rest;\n      }\n      return new P.Result(values, rest);\n    };\n  };\n  P.pick = function() {\n    var indexes, parsers;\n    indexes = arguments[0], parsers = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    return function(input) {\n      var array, result;\n      result = P.sequence.apply(P, parsers)(input);\n      if (result == null) {\n        return;\n      }\n      array = result.value;\n      result.value = array[indexes];\n      return result;\n    };\n  };\n  P.string = function(string) {\n    var length;\n    length = string.length;\n    return function(input) {\n      if (input.slice(0, length) === string) {\n        return new P.Result(string, input.slice(length));\n      }\n    };\n  };\n  P.lazy = function(fn) {\n    var cached;\n    cached = null;\n    return function(input) {\n      if (cached == null) {\n        cached = fn();\n      }\n      return cached(input);\n    };\n  };\n  P.baseMany = function(parser, end, stringResult, atLeastOneResultRequired, input) {\n    var endResult, parserResult, rest, results;\n    rest = input;\n    results = stringResult ? '' : [];\n    while (true) {\n      if (end != null) {\n        endResult = end(rest);\n        if (endResult != null) {\n          break;\n        }\n      }\n      parserResult = parser(rest);\n      if (parserResult == null) {\n        break;\n      }\n      if (stringResult) {\n        results += parserResult.value;\n      } else {\n        results.push(parserResult.value);\n      }\n      rest = parserResult.rest;\n    }\n    if (atLeastOneResultRequired && results.length === 0) {\n      return;\n    }\n    return new P.Result(results, rest);\n  };\n  P.many1 = function(parser) {\n    return function(input) {\n      return P.baseMany(parser, null, false, true, input);\n    };\n  };\n  P.concatMany1Till = function(parser, end) {\n    return function(input) {\n      return P.baseMany(parser, end, true, true, input);\n    };\n  };\n  P.firstChoice = function() {\n    var parsers;\n    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function(input) {\n      var i, length, parser, result;\n      i = -1;\n      length = parsers.length;\n      while (++i < length) {\n        parser = parsers[i];\n        result = parser(input);\n        if (result != null) {\n          return result;\n        }\n      }\n    };\n  };\n  newParser = function(options) {\n    var U;\n    U = {};\n    U.wildcard = P.tag('wildcard', P.string(options.wildcardChar));\n    U.optional = P.tag('optional', P.pick(1, P.string(options.optionalSegmentStartChar), P.lazy(function() {\n      return U.pattern;\n    }), P.string(options.optionalSegmentEndChar)));\n    U.name = P.regex(new RegExp(\"^[\" + options.segmentNameCharset + \"]+\"));\n    U.named = P.tag('named', P.pick(1, P.string(options.segmentNameStartChar), P.lazy(function() {\n      return U.name;\n    })));\n    U.escapedChar = P.pick(1, P.string(options.escapeChar), P.regex(/^./));\n    U[\"static\"] = P.tag('static', P.concatMany1Till(P.firstChoice(P.lazy(function() {\n      return U.escapedChar;\n    }), P.regex(/^./)), P.firstChoice(P.string(options.segmentNameStartChar), P.string(options.optionalSegmentStartChar), P.string(options.optionalSegmentEndChar), U.wildcard)));\n    U.token = P.lazy(function() {\n      return P.firstChoice(U.wildcard, U.optional, U.named, U[\"static\"]);\n    });\n    U.pattern = P.many1(P.lazy(function() {\n      return U.token;\n    }));\n    return U;\n  };\n  defaultOptions = {\n    escapeChar: '\\\\',\n    segmentNameStartChar: ':',\n    segmentValueCharset: 'a-zA-Z0-9-_~ %',\n    segmentNameCharset: 'a-zA-Z0-9',\n    optionalSegmentStartChar: '(',\n    optionalSegmentEndChar: ')',\n    wildcardChar: '*'\n  };\n  baseAstNodeToRegexString = function(astNode, segmentValueCharset) {\n    if (Array.isArray(astNode)) {\n      return stringConcatMap(astNode, function(node) {\n        return baseAstNodeToRegexString(node, segmentValueCharset);\n      });\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return '(.*?)';\n      case 'named':\n        return \"([\" + segmentValueCharset + \"]+)\";\n      case 'static':\n        return escapeForRegex(astNode.value);\n      case 'optional':\n        return '(?:' + baseAstNodeToRegexString(astNode.value, segmentValueCharset) + ')?';\n    }\n  };\n  astNodeToRegexString = function(astNode, segmentValueCharset) {\n    if (segmentValueCharset == null) {\n      segmentValueCharset = defaultOptions.segmentValueCharset;\n    }\n    return '^' + baseAstNodeToRegexString(astNode, segmentValueCharset) + '$';\n  };\n  astNodeToNames = function(astNode) {\n    if (Array.isArray(astNode)) {\n      return concatMap(astNode, astNodeToNames);\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return ['_'];\n      case 'named':\n        return [astNode.value];\n      case 'static':\n        return [];\n      case 'optional':\n        return astNodeToNames(astNode.value);\n    }\n  };\n  getParam = function(params, key, nextIndexes, sideEffects) {\n    var index, maxIndex, result, value;\n    if (sideEffects == null) {\n      sideEffects = false;\n    }\n    value = params[key];\n    if (value == null) {\n      if (sideEffects) {\n        throw new Error(\"no values provided for key `\" + key + \"`\");\n      } else {\n        return;\n      }\n    }\n    index = nextIndexes[key] || 0;\n    maxIndex = Array.isArray(value) ? value.length - 1 : 0;\n    if (index > maxIndex) {\n      if (sideEffects) {\n        throw new Error(\"too few values provided for key `\" + key + \"`\");\n      } else {\n        return;\n      }\n    }\n    result = Array.isArray(value) ? value[index] : value;\n    if (sideEffects) {\n      nextIndexes[key] = index + 1;\n    }\n    return result;\n  };\n  astNodeContainsSegmentsForProvidedParams = function(astNode, params, nextIndexes) {\n    var i, length;\n    if (Array.isArray(astNode)) {\n      i = -1;\n      length = astNode.length;\n      while (++i < length) {\n        if (astNodeContainsSegmentsForProvidedParams(astNode[i], params, nextIndexes)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return getParam(params, '_', nextIndexes, false) != null;\n      case 'named':\n        return getParam(params, astNode.value, nextIndexes, false) != null;\n      case 'static':\n        return false;\n      case 'optional':\n        return astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes);\n    }\n  };\n  stringify = function(astNode, params, nextIndexes) {\n    if (Array.isArray(astNode)) {\n      return stringConcatMap(astNode, function(node) {\n        return stringify(node, params, nextIndexes);\n      });\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return getParam(params, '_', nextIndexes, true);\n      case 'named':\n        return getParam(params, astNode.value, nextIndexes, true);\n      case 'static':\n        return astNode.value;\n      case 'optional':\n        if (astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes)) {\n          return stringify(astNode.value, params, nextIndexes);\n        } else {\n          return '';\n        }\n    }\n  };\n  UrlPattern = function(arg1, arg2) {\n    var groupCount, options, parsed, parser, withoutWhitespace;\n    if (arg1 instanceof UrlPattern) {\n      this.isRegex = arg1.isRegex;\n      this.regex = arg1.regex;\n      this.ast = arg1.ast;\n      this.names = arg1.names;\n      return;\n    }\n    this.isRegex = arg1 instanceof RegExp;\n    if (!(('string' === typeof arg1) || this.isRegex)) {\n      throw new TypeError('argument must be a regex or a string');\n    }\n    if (this.isRegex) {\n      this.regex = arg1;\n      if (arg2 != null) {\n        if (!Array.isArray(arg2)) {\n          throw new Error('if first argument is a regex the second argument may be an array of group names but you provided something else');\n        }\n        groupCount = regexGroupCount(this.regex);\n        if (arg2.length !== groupCount) {\n          throw new Error(\"regex contains \" + groupCount + \" groups but array of group names contains \" + arg2.length);\n        }\n        this.names = arg2;\n      }\n      return;\n    }\n    if (arg1 === '') {\n      throw new Error('argument must not be the empty string');\n    }\n    withoutWhitespace = arg1.replace(/\\s+/g, '');\n    if (withoutWhitespace !== arg1) {\n      throw new Error('argument must not contain whitespace');\n    }\n    options = {\n      escapeChar: (arg2 != null ? arg2.escapeChar : void 0) || defaultOptions.escapeChar,\n      segmentNameStartChar: (arg2 != null ? arg2.segmentNameStartChar : void 0) || defaultOptions.segmentNameStartChar,\n      segmentNameCharset: (arg2 != null ? arg2.segmentNameCharset : void 0) || defaultOptions.segmentNameCharset,\n      segmentValueCharset: (arg2 != null ? arg2.segmentValueCharset : void 0) || defaultOptions.segmentValueCharset,\n      optionalSegmentStartChar: (arg2 != null ? arg2.optionalSegmentStartChar : void 0) || defaultOptions.optionalSegmentStartChar,\n      optionalSegmentEndChar: (arg2 != null ? arg2.optionalSegmentEndChar : void 0) || defaultOptions.optionalSegmentEndChar,\n      wildcardChar: (arg2 != null ? arg2.wildcardChar : void 0) || defaultOptions.wildcardChar\n    };\n    parser = newParser(options);\n    parsed = parser.pattern(arg1);\n    if (parsed == null) {\n      throw new Error(\"couldn't parse pattern\");\n    }\n    if (parsed.rest !== '') {\n      throw new Error(\"could only partially parse pattern\");\n    }\n    this.ast = parsed.value;\n    this.regex = new RegExp(astNodeToRegexString(this.ast, options.segmentValueCharset));\n    this.names = astNodeToNames(this.ast);\n  };\n  UrlPattern.prototype.match = function(url) {\n    var groups, match;\n    match = this.regex.exec(url);\n    if (match == null) {\n      return null;\n    }\n    groups = match.slice(1);\n    if (this.names) {\n      return keysAndValuesToObject(this.names, groups);\n    } else {\n      return groups;\n    }\n  };\n  UrlPattern.prototype.stringify = function(params) {\n    if (params == null) {\n      params = {};\n    }\n    if (this.isRegex) {\n      throw new Error(\"can't stringify patterns generated from a regex\");\n    }\n    if (params !== Object(params)) {\n      throw new Error(\"argument must be an object or undefined\");\n    }\n    return stringify(this.ast, params, {});\n  };\n  UrlPattern.escapeForRegex = escapeForRegex;\n  UrlPattern.concatMap = concatMap;\n  UrlPattern.stringConcatMap = stringConcatMap;\n  UrlPattern.regexGroupCount = regexGroupCount;\n  UrlPattern.keysAndValuesToObject = keysAndValuesToObject;\n  UrlPattern.P = P;\n  UrlPattern.newParser = newParser;\n  UrlPattern.defaultOptions = defaultOptions;\n  UrlPattern.astNodeToRegexString = astNodeToRegexString;\n  UrlPattern.astNodeToNames = astNodeToNames;\n  UrlPattern.getParam = getParam;\n  UrlPattern.astNodeContainsSegmentsForProvidedParams = astNodeContainsSegmentsForProvidedParams;\n  UrlPattern.stringify = stringify;\n  return UrlPattern;\n});\n","var UrlPattern = require('url-pattern');\n\nfunction Router() {\n\tthis.useRoutes = [];\n\tthis.methodRoutes = {};\n\tthis.index = 0;\n}\n\nRouter.prototype.route = function() {\n\t// takes method, path, [request], respond\n\tif(arguments.length == 3) {\n\t\tvar request = {};\n\t\tvar respond = arguments[2];\n\t}\n\telse if(arguments.length >= 4) {\n\t\tvar request = arguments[2];\n\t\tif(typeof request !== \"object\" || !request)\n\t\t\trequest = {};\n\t\tvar respond = arguments[3];\n\t}\n\trequest.method = arguments[0];\n\n\tvar path = arguments[1];\n\tif(typeof request.path === 'undefined') // only overwrite path if doesn't already exist (carries through all routers)\n\t\trequest.path = path;\n\n\tvar queueEnd = arguments[4];\n\n\tvar routeMatches = this._methodPathMatches(request.method, path);\n\tqueueNext();\n\n\tfunction queueNext() {\n\t\tvar routeMatch = routeMatches.shift();\n\t\tif(typeof routeMatch !== \"undefined\") {\n\t\t\trequest.params = routeMatch.params; // overwrite params on each new route match\n\t\t\tif(typeof routeMatch.handler === \"function\")\n\t\t\t\trouteMatch.handler(request, respond, queueNext);\n\t\t\telse if(Router._isRouter(routeMatch.handler))\n\t\t\t\trouteMatch.handler.route(request.method, '/' + request.params['_'], request, respond, queueNext); // cycle through the router, then rejoin the queue\n\t\t\telse // route handler isn't a function or a router\n\t\t\t\tqueueNext();\n\t\t}\n\t\telse if(typeof queueEnd === 'function') // reached the end of the queue\n\t\t\tqueueEnd();\n\t}\n\n};\n\nRouter.prototype.use = function() {\n\t// [path], handler\n\tvar path = (typeof arguments[0] === 'string') ? arguments[0] : '';\n\tvar handler = Router._validHandler(arguments[0]) ? arguments[0] : arguments[1];\n\n\treturn this._addRouteToArray(this.useRoutes, Router._normalizePath(path), handler);\n};\n\nRouter.prototype.useFirst = function() {\n\t// [path], handler\n\tvar path = (typeof arguments[0] === 'string') ? arguments[0] : '';\n\tvar handler = Router._validHandler(arguments[0]) ? arguments[0] : arguments[1];\n\n\treturn this._addRouteToArray(this.useRoutes, Router._normalizePath(path), handler, true);\n};\n\nRouter.prototype.method = function(method, path, handler) {\n\tif(!(this.methodRoutes[method] instanceof Array)) // create the stack if it doesn't exist\n\t\tthis.methodRoutes[method] = [];\n\treturn this._addRouteToArray(this.methodRoutes[method], Router._normalizePath(path), handler);\n};\n\n/* Private functions */\nRouter._validHandler = function(handler) {\n\treturn (typeof handler === 'function' || Router._isRouter(handler)); // must be function or router\n};\n\nRouter._isRouter = function(handler) {\n\treturn (typeof handler === 'object' && typeof handler.route === 'function'); // must be function or router\n};\n\nRouter._normalizePath = function(path) {\n\treturn path.replace(/\\/$/, ''); // strip trailing slash\n};\n\nRouter.prototype._methodPathMatches = function(method, path) {\n\tvar pathNormalized = Router._normalizePath(path);\n\tvar matches = [];\n\tvar self = this;\n\n\tself.useRoutes.forEach(function(route) {\n\t\tvar routeMatch = (new UrlPattern(route.path + '(/*)')).match(pathNormalized);\n\t\t//console.log(\"RU\", routeMatch, route.path, pathNormalized);\n\t\tif(routeMatch !== null)\n\t\t\tmatches.push({path: route.path, handler: route.handler, params: routeMatch});\n\t});\n\n\tif(self.methodRoutes[method] instanceof Array) {\n\t\tself.methodRoutes[method].forEach(function(route) {\n\t\t\tvar routeMatch = (new UrlPattern(route.path)).match(pathNormalized);\n\t\t\t//console.log(\"RM\", route.path, pathNormalized, routeMatch);\n\t\t\tif(routeMatch !== null)\n\t\t\t\tmatches.push({path: route.path, handler: route.handler, params: routeMatch});\n\t\t});\n\t}\n\n\treturn matches;\n};\n\nRouter.prototype._addRouteToArray = function(array, path, handler, prepend) {\n\tvar route = {path: path, handler: handler};\n\tif(typeof prepend === 'boolean') //prepend\n\t\tarray.unshift(route);\n\telse //append\n\t\tarray.push(route);\n};\n\nmodule.exports = function() {\n\treturn new Router();\n};\n"]}