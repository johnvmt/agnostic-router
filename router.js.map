{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/url-pattern/lib/url-pattern.js","src/Router.js"],"names":["slice","root","factory","define","amd","exports","module","UrlPattern","this","P","astNodeContainsSegmentsForProvidedParams","astNodeToNames","astNodeToRegexString","baseAstNodeToRegexString","concatMap","defaultOptions","escapeForRegex","getParam","keysAndValuesToObject","newParser","regexGroupCount","stringConcatMap","stringify","string","replace","array","f","i","length","results","concat","result","regex","RegExp","toString","exec","keys","values","key","object","value","Array","isArray","push","Result","rest","Tagged","tag","parser","input","tagged","matches","sequence","parsers","arguments","call","pick","indexes","apply","lazy","fn","cached","baseMany","end","stringResult","atLeastOneResultRequired","parserResult","many1","concatMany1Till","firstChoice","options","U","wildcard","wildcardChar","optional","optionalSegmentStartChar","pattern","optionalSegmentEndChar","name","segmentNameCharset","named","segmentNameStartChar","escapedChar","escapeChar","token","segmentValueCharset","astNode","node","params","nextIndexes","sideEffects","index","maxIndex","Error","arg1","arg2","groupCount","parsed","isRegex","ast","names","TypeError","prototype","match","url","groups","Object","Router","useRoutes","methodRoutes","require","route","queueNext","routeMatch","routeMatches","shift","request","handler","respond","_isRouter","method","queueEnd","path","_methodPathMatches","use","_validHandler","_addRouteToArray","_normalizePath","useFirst","pathNormalized","self","forEach","prepend","unshift"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// Generated by CoffeeScript 1.10.0\nvar slice = [].slice;\n\n(function(root, factory) {\n  if (('function' === typeof define) && (define.amd != null)) {\n    return define([], factory);\n  } else if (typeof exports !== \"undefined\" && exports !== null) {\n    return module.exports = factory();\n  } else {\n    return root.UrlPattern = factory();\n  }\n})(this, function() {\n  var P, UrlPattern, astNodeContainsSegmentsForProvidedParams, astNodeToNames, astNodeToRegexString, baseAstNodeToRegexString, concatMap, defaultOptions, escapeForRegex, getParam, keysAndValuesToObject, newParser, regexGroupCount, stringConcatMap, stringify;\n  escapeForRegex = function(string) {\n    return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  };\n  concatMap = function(array, f) {\n    var i, length, results;\n    results = [];\n    i = -1;\n    length = array.length;\n    while (++i < length) {\n      results = results.concat(f(array[i]));\n    }\n    return results;\n  };\n  stringConcatMap = function(array, f) {\n    var i, length, result;\n    result = '';\n    i = -1;\n    length = array.length;\n    while (++i < length) {\n      result += f(array[i]);\n    }\n    return result;\n  };\n  regexGroupCount = function(regex) {\n    return (new RegExp(regex.toString() + '|')).exec('').length - 1;\n  };\n  keysAndValuesToObject = function(keys, values) {\n    var i, key, length, object, value;\n    object = {};\n    i = -1;\n    length = keys.length;\n    while (++i < length) {\n      key = keys[i];\n      value = values[i];\n      if (value == null) {\n        continue;\n      }\n      if (object[key] != null) {\n        if (!Array.isArray(object[key])) {\n          object[key] = [object[key]];\n        }\n        object[key].push(value);\n      } else {\n        object[key] = value;\n      }\n    }\n    return object;\n  };\n  P = {};\n  P.Result = function(value, rest) {\n    this.value = value;\n    this.rest = rest;\n  };\n  P.Tagged = function(tag, value) {\n    this.tag = tag;\n    this.value = value;\n  };\n  P.tag = function(tag, parser) {\n    return function(input) {\n      var result, tagged;\n      result = parser(input);\n      if (result == null) {\n        return;\n      }\n      tagged = new P.Tagged(tag, result.value);\n      return new P.Result(tagged, result.rest);\n    };\n  };\n  P.regex = function(regex) {\n    return function(input) {\n      var matches, result;\n      matches = regex.exec(input);\n      if (matches == null) {\n        return;\n      }\n      result = matches[0];\n      return new P.Result(result, input.slice(result.length));\n    };\n  };\n  P.sequence = function() {\n    var parsers;\n    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function(input) {\n      var i, length, parser, rest, result, values;\n      i = -1;\n      length = parsers.length;\n      values = [];\n      rest = input;\n      while (++i < length) {\n        parser = parsers[i];\n        result = parser(rest);\n        if (result == null) {\n          return;\n        }\n        values.push(result.value);\n        rest = result.rest;\n      }\n      return new P.Result(values, rest);\n    };\n  };\n  P.pick = function() {\n    var indexes, parsers;\n    indexes = arguments[0], parsers = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    return function(input) {\n      var array, result;\n      result = P.sequence.apply(P, parsers)(input);\n      if (result == null) {\n        return;\n      }\n      array = result.value;\n      result.value = array[indexes];\n      return result;\n    };\n  };\n  P.string = function(string) {\n    var length;\n    length = string.length;\n    return function(input) {\n      if (input.slice(0, length) === string) {\n        return new P.Result(string, input.slice(length));\n      }\n    };\n  };\n  P.lazy = function(fn) {\n    var cached;\n    cached = null;\n    return function(input) {\n      if (cached == null) {\n        cached = fn();\n      }\n      return cached(input);\n    };\n  };\n  P.baseMany = function(parser, end, stringResult, atLeastOneResultRequired, input) {\n    var endResult, parserResult, rest, results;\n    rest = input;\n    results = stringResult ? '' : [];\n    while (true) {\n      if (end != null) {\n        endResult = end(rest);\n        if (endResult != null) {\n          break;\n        }\n      }\n      parserResult = parser(rest);\n      if (parserResult == null) {\n        break;\n      }\n      if (stringResult) {\n        results += parserResult.value;\n      } else {\n        results.push(parserResult.value);\n      }\n      rest = parserResult.rest;\n    }\n    if (atLeastOneResultRequired && results.length === 0) {\n      return;\n    }\n    return new P.Result(results, rest);\n  };\n  P.many1 = function(parser) {\n    return function(input) {\n      return P.baseMany(parser, null, false, true, input);\n    };\n  };\n  P.concatMany1Till = function(parser, end) {\n    return function(input) {\n      return P.baseMany(parser, end, true, true, input);\n    };\n  };\n  P.firstChoice = function() {\n    var parsers;\n    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function(input) {\n      var i, length, parser, result;\n      i = -1;\n      length = parsers.length;\n      while (++i < length) {\n        parser = parsers[i];\n        result = parser(input);\n        if (result != null) {\n          return result;\n        }\n      }\n    };\n  };\n  newParser = function(options) {\n    var U;\n    U = {};\n    U.wildcard = P.tag('wildcard', P.string(options.wildcardChar));\n    U.optional = P.tag('optional', P.pick(1, P.string(options.optionalSegmentStartChar), P.lazy(function() {\n      return U.pattern;\n    }), P.string(options.optionalSegmentEndChar)));\n    U.name = P.regex(new RegExp(\"^[\" + options.segmentNameCharset + \"]+\"));\n    U.named = P.tag('named', P.pick(1, P.string(options.segmentNameStartChar), P.lazy(function() {\n      return U.name;\n    })));\n    U.escapedChar = P.pick(1, P.string(options.escapeChar), P.regex(/^./));\n    U[\"static\"] = P.tag('static', P.concatMany1Till(P.firstChoice(P.lazy(function() {\n      return U.escapedChar;\n    }), P.regex(/^./)), P.firstChoice(P.string(options.segmentNameStartChar), P.string(options.optionalSegmentStartChar), P.string(options.optionalSegmentEndChar), U.wildcard)));\n    U.token = P.lazy(function() {\n      return P.firstChoice(U.wildcard, U.optional, U.named, U[\"static\"]);\n    });\n    U.pattern = P.many1(P.lazy(function() {\n      return U.token;\n    }));\n    return U;\n  };\n  defaultOptions = {\n    escapeChar: '\\\\',\n    segmentNameStartChar: ':',\n    segmentValueCharset: 'a-zA-Z0-9-_~ %',\n    segmentNameCharset: 'a-zA-Z0-9',\n    optionalSegmentStartChar: '(',\n    optionalSegmentEndChar: ')',\n    wildcardChar: '*'\n  };\n  baseAstNodeToRegexString = function(astNode, segmentValueCharset) {\n    if (Array.isArray(astNode)) {\n      return stringConcatMap(astNode, function(node) {\n        return baseAstNodeToRegexString(node, segmentValueCharset);\n      });\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return '(.*?)';\n      case 'named':\n        return \"([\" + segmentValueCharset + \"]+)\";\n      case 'static':\n        return escapeForRegex(astNode.value);\n      case 'optional':\n        return '(?:' + baseAstNodeToRegexString(astNode.value, segmentValueCharset) + ')?';\n    }\n  };\n  astNodeToRegexString = function(astNode, segmentValueCharset) {\n    if (segmentValueCharset == null) {\n      segmentValueCharset = defaultOptions.segmentValueCharset;\n    }\n    return '^' + baseAstNodeToRegexString(astNode, segmentValueCharset) + '$';\n  };\n  astNodeToNames = function(astNode) {\n    if (Array.isArray(astNode)) {\n      return concatMap(astNode, astNodeToNames);\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return ['_'];\n      case 'named':\n        return [astNode.value];\n      case 'static':\n        return [];\n      case 'optional':\n        return astNodeToNames(astNode.value);\n    }\n  };\n  getParam = function(params, key, nextIndexes, sideEffects) {\n    var index, maxIndex, result, value;\n    if (sideEffects == null) {\n      sideEffects = false;\n    }\n    value = params[key];\n    if (value == null) {\n      if (sideEffects) {\n        throw new Error(\"no values provided for key `\" + key + \"`\");\n      } else {\n        return;\n      }\n    }\n    index = nextIndexes[key] || 0;\n    maxIndex = Array.isArray(value) ? value.length - 1 : 0;\n    if (index > maxIndex) {\n      if (sideEffects) {\n        throw new Error(\"too few values provided for key `\" + key + \"`\");\n      } else {\n        return;\n      }\n    }\n    result = Array.isArray(value) ? value[index] : value;\n    if (sideEffects) {\n      nextIndexes[key] = index + 1;\n    }\n    return result;\n  };\n  astNodeContainsSegmentsForProvidedParams = function(astNode, params, nextIndexes) {\n    var i, length;\n    if (Array.isArray(astNode)) {\n      i = -1;\n      length = astNode.length;\n      while (++i < length) {\n        if (astNodeContainsSegmentsForProvidedParams(astNode[i], params, nextIndexes)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return getParam(params, '_', nextIndexes, false) != null;\n      case 'named':\n        return getParam(params, astNode.value, nextIndexes, false) != null;\n      case 'static':\n        return false;\n      case 'optional':\n        return astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes);\n    }\n  };\n  stringify = function(astNode, params, nextIndexes) {\n    if (Array.isArray(astNode)) {\n      return stringConcatMap(astNode, function(node) {\n        return stringify(node, params, nextIndexes);\n      });\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return getParam(params, '_', nextIndexes, true);\n      case 'named':\n        return getParam(params, astNode.value, nextIndexes, true);\n      case 'static':\n        return astNode.value;\n      case 'optional':\n        if (astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes)) {\n          return stringify(astNode.value, params, nextIndexes);\n        } else {\n          return '';\n        }\n    }\n  };\n  UrlPattern = function(arg1, arg2) {\n    var groupCount, options, parsed, parser, withoutWhitespace;\n    if (arg1 instanceof UrlPattern) {\n      this.isRegex = arg1.isRegex;\n      this.regex = arg1.regex;\n      this.ast = arg1.ast;\n      this.names = arg1.names;\n      return;\n    }\n    this.isRegex = arg1 instanceof RegExp;\n    if (!(('string' === typeof arg1) || this.isRegex)) {\n      throw new TypeError('argument must be a regex or a string');\n    }\n    if (this.isRegex) {\n      this.regex = arg1;\n      if (arg2 != null) {\n        if (!Array.isArray(arg2)) {\n          throw new Error('if first argument is a regex the second argument may be an array of group names but you provided something else');\n        }\n        groupCount = regexGroupCount(this.regex);\n        if (arg2.length !== groupCount) {\n          throw new Error(\"regex contains \" + groupCount + \" groups but array of group names contains \" + arg2.length);\n        }\n        this.names = arg2;\n      }\n      return;\n    }\n    if (arg1 === '') {\n      throw new Error('argument must not be the empty string');\n    }\n    withoutWhitespace = arg1.replace(/\\s+/g, '');\n    if (withoutWhitespace !== arg1) {\n      throw new Error('argument must not contain whitespace');\n    }\n    options = {\n      escapeChar: (arg2 != null ? arg2.escapeChar : void 0) || defaultOptions.escapeChar,\n      segmentNameStartChar: (arg2 != null ? arg2.segmentNameStartChar : void 0) || defaultOptions.segmentNameStartChar,\n      segmentNameCharset: (arg2 != null ? arg2.segmentNameCharset : void 0) || defaultOptions.segmentNameCharset,\n      segmentValueCharset: (arg2 != null ? arg2.segmentValueCharset : void 0) || defaultOptions.segmentValueCharset,\n      optionalSegmentStartChar: (arg2 != null ? arg2.optionalSegmentStartChar : void 0) || defaultOptions.optionalSegmentStartChar,\n      optionalSegmentEndChar: (arg2 != null ? arg2.optionalSegmentEndChar : void 0) || defaultOptions.optionalSegmentEndChar,\n      wildcardChar: (arg2 != null ? arg2.wildcardChar : void 0) || defaultOptions.wildcardChar\n    };\n    parser = newParser(options);\n    parsed = parser.pattern(arg1);\n    if (parsed == null) {\n      throw new Error(\"couldn't parse pattern\");\n    }\n    if (parsed.rest !== '') {\n      throw new Error(\"could only partially parse pattern\");\n    }\n    this.ast = parsed.value;\n    this.regex = new RegExp(astNodeToRegexString(this.ast, options.segmentValueCharset));\n    this.names = astNodeToNames(this.ast);\n  };\n  UrlPattern.prototype.match = function(url) {\n    var groups, match;\n    match = this.regex.exec(url);\n    if (match == null) {\n      return null;\n    }\n    groups = match.slice(1);\n    if (this.names) {\n      return keysAndValuesToObject(this.names, groups);\n    } else {\n      return groups;\n    }\n  };\n  UrlPattern.prototype.stringify = function(params) {\n    if (params == null) {\n      params = {};\n    }\n    if (this.isRegex) {\n      throw new Error(\"can't stringify patterns generated from a regex\");\n    }\n    if (params !== Object(params)) {\n      throw new Error(\"argument must be an object or undefined\");\n    }\n    return stringify(this.ast, params, {});\n  };\n  UrlPattern.escapeForRegex = escapeForRegex;\n  UrlPattern.concatMap = concatMap;\n  UrlPattern.stringConcatMap = stringConcatMap;\n  UrlPattern.regexGroupCount = regexGroupCount;\n  UrlPattern.keysAndValuesToObject = keysAndValuesToObject;\n  UrlPattern.P = P;\n  UrlPattern.newParser = newParser;\n  UrlPattern.defaultOptions = defaultOptions;\n  UrlPattern.astNodeToRegexString = astNodeToRegexString;\n  UrlPattern.astNodeToNames = astNodeToNames;\n  UrlPattern.getParam = getParam;\n  UrlPattern.astNodeContainsSegmentsForProvidedParams = astNodeContainsSegmentsForProvidedParams;\n  UrlPattern.stringify = stringify;\n  return UrlPattern;\n});\n","var UrlPattern = require('url-pattern');\n\nfunction Router(options) {\n\tthis.options = (typeof options == 'object') ? options : {};\n\tthis.useRoutes = [];\n\tthis.methodRoutes = {};\n\tthis.index = 0;\n\tthis.UrlPattern = UrlPattern;\n}\n\nRouter.prototype.route = function() {\n\t// takes method, path, [request], respond\n\tif(arguments.length == 3) {\n\t\tvar request = {};\n\t\tvar respond = arguments[2];\n\t}\n\telse if(arguments.length >= 4) {\n\t\tvar request = arguments[2];\n\t\tif(typeof request !== \"object\" || !request)\n\t\t\trequest = {};\n\t\tvar respond = arguments[3];\n\t}\n\trequest.method = arguments[0];\n\n\tvar path = arguments[1];\n\tif(typeof request.path === 'undefined') // only overwrite path if doesn't already exist (carries through all routers)\n\t\trequest.path = path;\n\n\tvar queueEnd = arguments[4];\n\n\tvar routeMatches = this._methodPathMatches(request.method, path);\n\tqueueNext();\n\n\tfunction queueNext() {\n\t\tvar routeMatch = routeMatches.shift();\n\t\tif(typeof routeMatch !== \"undefined\") {\n\t\t\trequest.params = routeMatch.params; // overwrite params on each new route match\n\t\t\tif(typeof routeMatch.handler === \"function\")\n\t\t\t\trouteMatch.handler(request, respond, queueNext);\n\t\t\telse if(Router._isRouter(routeMatch.handler))\n\t\t\t\trouteMatch.handler.route(request.method, '/' + request.params['_'], request, respond, queueNext); // cycle through the router, then rejoin the queue\n\t\t\telse // route handler isn't a function or a router\n\t\t\t\tqueueNext();\n\t\t}\n\t\telse if(typeof queueEnd === 'function') // reached the end of the queue\n\t\t\tqueueEnd();\n\t}\n\n};\n\nRouter.prototype.use = function() {\n\t// [path], handler\n\tvar path = (typeof arguments[0] === 'string') ? arguments[0] : '';\n\tvar handler = Router._validHandler(arguments[0]) ? arguments[0] : arguments[1];\n\n\treturn this._addRouteToArray(this.useRoutes, Router._normalizePath(path), handler);\n};\n\nRouter.prototype.useFirst = function() {\n\t// [path], handler\n\tvar path = (typeof arguments[0] === 'string') ? arguments[0] : '';\n\tvar handler = Router._validHandler(arguments[0]) ? arguments[0] : arguments[1];\n\n\treturn this._addRouteToArray(this.useRoutes, Router._normalizePath(path), handler, true);\n};\n\nRouter.prototype.method = function(method, path, handler) {\n\tif(!(this.methodRoutes[method] instanceof Array)) // create the stack if it doesn't exist\n\t\tthis.methodRoutes[method] = [];\n\treturn this._addRouteToArray(this.methodRoutes[method], Router._normalizePath(path), handler);\n};\n\n/* Private functions */\nRouter._validHandler = function(handler) {\n\treturn (typeof handler === 'function' || Router._isRouter(handler)); // must be function or router\n};\n\nRouter._isRouter = function(handler) {\n\treturn (typeof handler === 'object' && typeof handler.route === 'function'); // must be function or router\n};\n\nRouter._normalizePath = function(path) {\n\treturn path.replace(/\\/$/, ''); // strip trailing slash\n};\n\nRouter.prototype._methodPathMatches = function(method, path) {\n\tvar pathNormalized = Router._normalizePath(path);\n\tvar matches = [];\n\tvar self = this;\n\n\tself.useRoutes.forEach(function(route) {\n\t\tvar routeMatch = (new UrlPattern(route.path + '(/*)', self.options)).match(pathNormalized);\n\t\t//console.log(\"RU\", routeMatch, route.path, pathNormalized);\n\t\tif(routeMatch !== null)\n\t\t\tmatches.push({path: route.path, handler: route.handler, params: routeMatch});\n\t});\n\n\tif(self.methodRoutes[method] instanceof Array) {\n\t\tself.methodRoutes[method].forEach(function(route) {\n\t\t\tvar routeMatch = (new UrlPattern(route.path, self.options)).match(pathNormalized);\n\t\t\t//console.log(\"RM\", route.path, pathNormalized, routeMatch);\n\t\t\tif(routeMatch !== null)\n\t\t\t\tmatches.push({path: route.path, handler: route.handler, params: routeMatch});\n\t\t});\n\t}\n\n\treturn matches;\n};\n\nRouter.prototype._addRouteToArray = function(array, path, handler, prepend) {\n\tvar route = {path: path, handler: handler};\n\tif(typeof prepend === 'boolean') //prepend\n\t\tarray.unshift(route);\n\telse //append\n\t\tarray.push(route);\n};\n\nmodule.exports = function(options) {\n\treturn new Router(options);\n};\n"]}